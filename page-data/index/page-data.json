{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Cha-Ji","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"프로세스 프로그램은 실행할 수 있는 파일을 말하며 코드 덩어리에 불과합니다.\n프로세스는 실행되고 있는 프로그램의 인스턴스를 뜻합니다. 독립된 Code, Data, Stack, Heap 메모리 영역을 할당받으며 최소 1개의 스레드를 갖습니다.\n다른 프로세스의 자원에 접근하기 위해서는 IPC를 사용하게 됩니다. 쓰레드 스레드는 프로세스가 할당받은 자원을 사용…","fields":{"slug":"/O.S./thread_vs_process/"},"frontmatter":{"date":"August 07, 2022","title":"[O.S.] Thread vs Process","category":"O.S.","draft":false}}},{"node":{"excerpt":"B+Tree DB에서 널리 사용되는 트리 자료구조의 일종으로, 이진트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리구조가 B트리입니다.\n이와 비슷한 B+트리는 모든 레코드들이 트리의 최하위 레벨에 정렬되어 있고 오직 키들만 내부 블록에 저장됩니다.\n리프노드를 연결리스트 형태로 연결한 트리이며 최대 key 개수가 정해져있다…","fields":{"slug":"/D.S./b_plus_tree/"},"frontmatter":{"date":"August 07, 2022","title":"[자료구조] B+ Tree","category":"D.S.","draft":false}}},{"node":{"excerpt":"Heap 완전 이진트리이며, 최솟값이나 최댓값을 빠르게 찾을 수 있는 자료구조입니다.\n이진탐색트리와 달리 중복된 값을 허용합니다. 구현 배열로 트리와 유사하게 만듭니다.\n왼쪽자식은 부모인덱스 * 2, 오른쪽 자식은 부모인덱스 * 2 + 1로 계산합니다. 삽입 노드를 만들어 힙의 마지막노드 뒤에 삽입합니다. 부모를 제쳐가며 본인의 위치를 찾아갑니다. 삭제 …","fields":{"slug":"/D.S./heap/"},"frontmatter":{"date":"August 07, 2022","title":"[자료구조] Heap","category":"D.S.","draft":false}}},{"node":{"excerpt":"Red Black Tree BST는 삽입, 탐색, 삭제 연산이 O(h)의 시간복잡도를 갖습니다. (h는 트리의 높이)\n트리의 밸런스가 무너진다면 트리의 높이는 N이 될 수 있습니다.\n기존 BST 자료구조에서 트리의 균형을 잡아 최악의 경우를 없애 O(logN)을 유지하기 위해 Red-Black Tree를 사용합니다. 규칙 Color Red의 자식은 Bla…","fields":{"slug":"/D.S./red_black_tree/"},"frontmatter":{"date":"August 06, 2022","title":"[자료구조] Red-Black-Tree","category":"D.S.","draft":false}}},{"node":{"excerpt":"구현 간단한 해시테이블을 구현하기 위해선, 연결리스트와 해시코드 함수만 있으면 됩니다.\n다음과 같은 순서로 구현할 수 있으며, 을 조심해야합니다. 키의 해시코드 계산하기 배열의 인덱스 구하기. 키와 값을 해당 인덱스에 저장하기. 이 때 충돌이란 서로 다른 두 개의 키가 같은 해시코드를 가리키거나 같은 인덱스를 가리키는 경우를 말합니다.\n와 은 유한하기 때…","fields":{"slug":"/D.S./hash_table/"},"frontmatter":{"date":"August 06, 2022","title":"[자료구조] 해시테이블","category":"D.S.","draft":false}}},{"node":{"excerpt":"Github Blog 기존에도 블로그를 소소하게 올리고 있엇꼬 원래 tistory를 사용하고 있었지만, 글은 항상 마크다운 언어로 작성했습니다.\n글을 마크다운으로 작성하고 복사붙여넣기를 하거나 이미지를 삽입하는 과정에서 불편함을 느꼈고,\n조금더 마크다운스러운 블로그 플랫폼으로 이사를 갈까? 고민했습니다. Velog Github 개발자들의 블로그인 velo…","fields":{"slug":"/etc/blog_init/"},"frontmatter":{"date":"July 12, 2022","title":"[etc] 블로그 이사","category":"etc","draft":false}}},{"node":{"excerpt":"이 글은 좋은 코드에 대해 고민하는 글이며 jbee님 블로그 글을 읽고 고민한 내용과 함께 재구성한 글입니다. 좋은 코드 좋은 코드는 가독성 좋은 코드, 테스트하기 좋은 코드, 중복 없는 코드 등 주관적인 의견을 내세웁니다.\n이 글에서는 이에 대해 고민합니다. 가독성 가독성이 좋은 코드가 좋은 코드일까요? 함께 개발하기 위해서는 내 코드가 잘 읽혀야 팀원…","fields":{"slug":"/etc/개발상식/"},"frontmatter":{"date":"July 11, 2022","title":"[etc] 좋은 코드","category":"etc","draft":false}}},{"node":{"excerpt":"안드로이드 앱을 구현할 때에는 컴포넌트 클래스와 일반 클래스를 구현하게 됩니다.\n그 중 컴포넌트 클래스는 개발자가 아닌 안드로이드가 생명주기를 관리하는 클래스라고 볼 수 있습니다.\n이후에는 4대 컴포넌트라고 일컫는 액티비티, 서비스, 브로드캐스트 리시버, 콘텐츠 프로바이더에 대해 정리해보고자 합니다.\n이 글은 먼저 Activity를 정리합니다. 인텐트 컴…","fields":{"slug":"/Android/activity/"},"frontmatter":{"date":"July 11, 2022","title":"[Android] Activity Component","category":"Android","draft":false}}},{"node":{"excerpt":"컴퓨터의 두 가지 주요 작업은 계산과 입출력 작업입니다.\n이 중 입출력 작업이 더 중요한 경우가 많습니다.\n이 글에서는 운영체제의 입출력 서브시스템의 구조를 살펴봅니다. 인터럽트 CPU는 명령어를 끝내고 다음 명령을 수행하기 전 항상 이 인터럽트 요청 라인을 검사합니다. 예기치 않은 상황을 만났을 때, 현재보다 더 중요한 일이 발생했을 때 인터럽트가 발생…","fields":{"slug":"/O.S./11_io_system/"},"frontmatter":{"date":"July 11, 2022","title":"[공룡책] 입출력 시스템","category":"O.S.","draft":false}}},{"node":{"excerpt":"이 글에서는 컴퓨터의 비휘발성 저장장치 시스템인 대용량 저장장치가 어떻게 구성되어 있는지 설명합니다.\n최신 컴퓨터의 대용량 저장장치 시스템은 보조저장장치이며 일반적으로 HDD 및 NVM 장치를 사용하여 제공됩니다. NVM Nonvolatile Memory Devices, 비휘발성 메모리 장치 기계식이 아니며 전기식이다. SSD(solid-state dis…","fields":{"slug":"/O.S./10_대용량_저장장치_구조/"},"frontmatter":{"date":"July 11, 2022","title":"[공룡책] 대용량 저장장치 구조","category":"O.S.","draft":false}}},{"node":{"excerpt":"MVVM 패턴을 적용하다보면 View와 ViewModel의 관심사 분리를 위해 노력하곤 합니다. 그 중 이벤트 처리와 데이터를 다루는 객체로 LiveData를 사용했습니다. 기존에 사용하던 LiveData에서 Coroutine Flow로 마이그레이션하며 개념을 정리하려 합니다. 짧은 사전 설명 xml에서 버튼을 클릭하면 Fragment에서는 원하는 화면으…","fields":{"slug":"/Android/livedata_to_flow/"},"frontmatter":{"date":"November 06, 2021","title":"[Kotlin] LiveData -> Coroutine Flow","category":"Android","draft":false}}},{"node":{"excerpt":"리플렉션 객체를 통해 클래스의 정보를 분석하는 기법입니다. Class.class ⇒ Class 클래스의 객체는 자바 프로그램에서 사용되는 클래스들과 인터페이스들을 나타낸다. 사용 가능한 클래스의 인스턴스가 없을 때 .class를 사용하곤 합니다. 인스턴스가 있다면 getClass() 메서드로 얻을 수 있습니다. 코드 리플렉션에 사용됩니다. 정규화 된 클래…","fields":{"slug":"/Android/reflection/"},"frontmatter":{"date":"November 06, 2021","title":"[Java] Reflection","category":"Android","draft":false}}},{"node":{"excerpt":"inline inline 키워드는 함수 선언 키워드인 fun 앞에 붙습니다. inline 키워드는 함수 구현 자체를 코드에 넣어 오버헤드를 줄이는 키워드입니다. 코드 예시 고차함수 해당 코드를 자바코드로 디컴파일하면 아래처럼 동작합니다. (가독성을 위해 코틀린 코드로 동작원리만 비슷하게 작성했습니다.) inline 키워드 사용 같은 코드를 inline으로…","fields":{"slug":"/Android/inline_function/"},"frontmatter":{"date":"November 05, 2021","title":"[Kotlin] inline function","category":"Android","draft":false}}},{"node":{"excerpt":"DI는 Dependency Injection의 준말로, 의존성 주입을 뜻합니다. DI Android에서 데이터를 관리할 때 ViewModel을 사용하곤 합니다. Repository 패턴도 함께 사용할 때가 많은데, 각설하고 코드로 예시를 보이겠습니다. 위 코드에서 ViewModel의 fetch 함수는 repository라는 변수가 필요합니다. 이 코드를 …","fields":{"slug":"/Android/di_init/"},"frontmatter":{"date":"November 04, 2021","title":"[DI] Android에서의 DI 첫걸음","category":"Android","draft":false}}},{"node":{"excerpt":"Single Live Event & Event wrapper Data를 다루는 LiveData객체를 활용해 이벤트 발생을 처리하는 방법. 간단한 구현 특정 이벤트가 발생할 때마다 실행시켜야 하는 함수가 있다면 다음과 같이 구현할 수 있습니다. button이 클릭될 때마다 event객체에 Unit값을 set 해줍니다. event객체를 observe해서 위 …","fields":{"slug":"/Android/event_wrapper/"},"frontmatter":{"date":"November 04, 2021","title":"[Android] Single Live Event & Event wrapper","category":"Android","draft":false}}},{"node":{"excerpt":"프레임의 3가지 단계 Composition → Layout → Drawing 1. Composition Composable이 생성되는 단계입니다. 생성이 되면 다음 단계를 수행합니다. 2. Layout measurement, placement 두 단계가 존재합니다. 재배치를 하더라도 재측정을 하지는 않습니다. 3. Drawing Canvas를 호출하거나 …","fields":{"slug":"/Android/compose_phases/"},"frontmatter":{"date":"November 03, 2021","title":"[Compose] Phases","category":"Android","draft":false}}},{"node":{"excerpt":"Side effects 일반적인 수명주기에서 더 복잡한 작업을 수행할 때 Side Effects를 필요로 합니다. LaunchedEffect Composable 내에서 suspend 함수를 호출할 때 사용 매개변수 중 하나가 변경되면 재호출 ex) 스낵바 호출, 스크롤 등의 일반적인 동작 rememberCoroutineScope Composable 외부에…","fields":{"slug":"/Android/compose_side_effects/"},"frontmatter":{"date":"November 03, 2021","title":"[Compose] Side Effects","category":"Android","draft":false}}},{"node":{"excerpt":"이 글은 RecyclerView로 구성된 한 화면을 Compose로 변경해보며 느낀점과 compose의 기본 개념을 서술합니다. Compose의 특징 적은 수의 코드 손쉬운 유지보수 실시간 미리보기 기능 빠른 개발시간 선언형 프로그래밍 화면 전체를 개념적으로 재생성한 후 변경사항만 적용하는 방식을 적용할 수 있었습니다. 적용 이유와 후기 기존 코드를 mi…","fields":{"slug":"/Android/compose_migration/"},"frontmatter":{"date":"November 03, 2021","title":"[Compose] Compose로 migration하기","category":"Android","draft":false}}},{"node":{"excerpt":"앞서 작성한 글에서 다중 프로그래밍을 실현하기 위한 이야기가 많이 등장했습니다. 다중 프로그래밍을 실현하기 위해 많은 프로세스를 동시에 메모리에 올려둬야 합니다. 가상 메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록하는 기법입니다. 프로그램이 물리 메모리보다 커도 된다는 장점이 있는 이 가상 메모리에 대해 작성해볼까 합니다. 가상…","fields":{"slug":"/O.S./9_virtual_memory/"},"frontmatter":{"date":"July 09, 2020","title":"[공룡책] 가상메모리","category":"O.S.","draft":false}}},{"node":{"excerpt":"단편화 이전 글에서 언급한 내외부 단편화를 간단히 정리했습니다. 내부 단편화 1gb의 메모리 공간에 990mb의 프로세스가 적재된다고 가정하겠습니다. 10mb의 공간이 남으며 새로운 프로세스를 적재하기엔 좁은 공간입니다. 필요 없는 기억자료가 할당된 영역 내부에 있지만, 쓰이지 않는 것을 내부 단편화라 합니다. 외부 단편화 두 개의 1gb의 메모리 공간에…","fields":{"slug":"/O.S./fragmentation/"},"frontmatter":{"date":"July 09, 2020","title":"[OS] 단편화","category":"O.S.","draft":false}}},{"node":{"excerpt":"가상기억 장치 시스템에서, 교체될 페이지의 내용이 변경되었는지를 표시하는 비트 페이징 앞선 글에서 페이징에 대해 언급했습니다. 페이징 기법은 데이터를 페이지 단위로 쪼개서 관리하는 기법입니다. 보조기억장치는 공간이 큰 대신 접근할 때 탐색이 어렵습니다. 때문에 자주 사용하는 데이터는 주기억장치에 두고 접근합니다. Dirty Bit write한 적 있는 d…","fields":{"slug":"/O.S./dirty_bit/"},"frontmatter":{"date":"July 09, 2020","title":"[OS] Dirty Bit","category":"O.S.","draft":false}}},{"node":{"excerpt":"CPU 스케줄링의 결과로 CPU 이용률과 사용자에게 제공하는 컴퓨터 응답속도를 향상할 수 있습니다. 하지만 이러한 성능 향상을 위해 많은 프로세스를 메모리에 유지해야합니다. 이 글에서는 메모리를 관리하는 다양한 방법에 관해 설명합니다. 주소할당 메모리 주소공간에서 명령어와 데이터 바인딩은 그 바인딩이 이루어지는 시점에 따라 다음과 같이 구분됩니다. Com…","fields":{"slug":"/O.S./8_main_memory/"},"frontmatter":{"date":"July 08, 2020","title":"[공룡책] 메인메모리","category":"O.S.","draft":false}}},{"node":{"excerpt":"이전 글에서 동기화에 대한 이야기를 하며 교착상태라는 이야기가 나왔습니다. Operating System - 동기화 Operating System - 동기화 예제 교착상태는 세마포가 Ready Queue 를 가지고 있고 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고 Critical Section 에서 실행되는 프로세스는 …","fields":{"slug":"/O.S./7_deadlock/"},"frontmatter":{"date":"July 07, 2020","title":"[공룡책] 교착상태","category":"O.S.","draft":false}}},{"node":{"excerpt":"Critical Section 문제를 해결하기 위해서는 3가지 조건이 충족해야 합니다. 세 가지 조건을 충족한 고전적인 방법으로 피터슨의 알고리즘이 존재합니다. 기본 개념 프로세스가 2개일 때만 가능하고, 3개일 때는 아직 연구중 자원을 공유하는 2개의 프로세스 간에는 Flag와 turn변수가 공유됩니다. turn은 PCB와 비슷한 개념입니다. 진입할 프…","fields":{"slug":"/O.S./peterson/"},"frontmatter":{"date":"July 07, 2020","title":"[OS] 피터슨의 알고리즘","category":"O.S.","draft":false}}},{"node":{"excerpt":"Operating System - 동기화 이전 글에서는 발생할 수 있는 문제에 대해 많이 언급했습니다. 또한 임계구역 문제, 경쟁조건이 없는 프로그램을 설계할 때 발생하는 문제, 교착상태, 라이브니스 위험 등을 언급했습니다. 이 글에서는 제시된 도구를 고전적인 동기화 문제에 적용합니다. 유한 버퍼 문제 먼저 유한 버퍼 문제가 존재합니다. Readers-W…","fields":{"slug":"/O.S./6_sync_ex/"},"frontmatter":{"date":"July 06, 2020","title":"[공룡책] 동기화 예제","category":"O.S.","draft":false}}},{"node":{"excerpt":"논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하며 이를 통해 데이터의 일관성을 유지하는 다양한 매커니즘을 논의합니다. 임계구역 Critical Section 각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서는 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있습니다. 임계구역 문제는 상호배제…","fields":{"slug":"/O.S./5_sync/"},"frontmatter":{"date":"July 05, 2020","title":"[공룡책] 동기화","category":"O.S.","draft":false}}},{"node":{"excerpt":"운영체제는 CPU를 프로세스 간 교환함으로써 보다 생산적으로 동작합니다. 코어가 하나인 시스템에선 한순간에 오직 하나의 프로세스만이 실행될 수 있습니다. 나머지 프로세스는 CPU의 코어가 가용 상태가 되어야 실행시킬 수 있으며 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행중인 프로세스를 가지게 하는 데 있습니다. 이 때 프로세스 또는…","fields":{"slug":"/O.S./4_scheduling/"},"frontmatter":{"date":"July 04, 2020","title":"[공룡책] CPU 스케줄링","category":"O.S.","draft":false}}},{"node":{"excerpt":"Multilevel Queue 여러개의 큐에 여러 스케줄링을 적용하는 기법 다단계 큐를 이해하기 앞서 다른 스케줄링 기법을 알 필요가 있습니다. 여기서 언급하는 기법은 FCFS, RR, Priority 세 기법입니다. 작업이 분류되고, Ready Queue에서는 우선순위에 맞게 작업이 스케줄링 됩니다. 시스템 작업, 대화형 작업, 일괄처리 작업 등으로 분…","fields":{"slug":"/O.S./queue/"},"frontmatter":{"date":"July 04, 2020","title":"[OS] 다단계 큐와 다단계 피드백 큐","category":"O.S.","draft":false}}},{"node":{"excerpt":"앞서 작성한 운영체제, 프로세스에 이어 스레드에 대해 간단히 이야기합니다. 스레드 CPU 이용의 기본 단위입니다. 스레드 ID, PC, 레지스터 집합, 스택으로 구성됩니다. 프로세스 vs 스레드 프로세스는 실행중인 프로그램의 인스턴스이며, 스레드는 실행되는 흐름의 단위입니다. 한 프로그램에서 둘 이상의 프로세스를 생성한다면 빈번한 context switc…","fields":{"slug":"/O.S./3_thread/"},"frontmatter":{"date":"July 03, 2020","title":"[공룡책] 스레드","category":"O.S.","draft":false}}},{"node":{"excerpt":"앞서 작성한 운영체제에 이어서 프로세스에 대해 간단히 이야기합니다. 프로세스 초기 컴퓨터 시스템은 한 번에 하나의 프로그램만을 실행시켰습니다. 반면 오늘날의 컴퓨터 시스템들은 메모리에 다수의 프로그램이 적재되어 병행 실행되는 것을 허용합니다. 프로세스란 실행중인 프로그램을 말합니다. 프로세스가 무엇이고 어떻게 표현되며 어떻게 동작하는지 알아보겠습니다. 프…","fields":{"slug":"/O.S./2_process/"},"frontmatter":{"date":"July 02, 2020","title":"[공룡책] 프로세스","category":"O.S.","draft":false}}},{"node":{"excerpt":"서론 서론에선 앞으로의 내용을 간단히 요약합니다. 이 후 작성하는 글은 운영체제, 프로세스, 스레드 순서대로 간단히 이야기합니다. 운영체제를 공부하기 전 운영체제가 뭔지, 운영체제를 왜 사용할까 정리하고 시작합니다. 운영체제 컴퓨터 하드웨어를 관리하는 소프트웨어 운영 체제는 컴퓨터 하드웨어가 컴퓨터 소프트웨어와 통신하고 작동하도록하는 소프트웨어 프로그램입…","fields":{"slug":"/O.S./1_os/"},"frontmatter":{"date":"July 01, 2020","title":"[공룡책] 운영체제","category":"O.S.","draft":false}}},{"node":{"excerpt":"데이터 바인딩 이전에 포스팅했던 View binding과 같이 뷰 속성을 참조하는 방식 중 하나입니다. View binding보다 성능은 떨어질 수 있습니다. 사용 전 build.gradle에서 android 블록에  를 추가해야 합니다. plugin 블록에 `id ‘kotlin-kapt’ 를 추가해야 합니다. 컴파일될 때 바인딩 클래스가 자동으로 구현됩…","fields":{"slug":"/Android/data_binding/"},"frontmatter":{"date":"July 03, 2000","title":"[Android] Data Binding","category":"Android","draft":false}}},{"node":{"excerpt":"View Binding 등장 배경 xml 상의 코드 즉, 화면에 나타나는 뷰를 참조할 때 findById와 같은 메서드로 접근하곤 합니다. 하지만 여러 문제가 생겼고, 대안을 고민하게 됩니다. 크게 세가지 지표로 고민을 했고, 거쳐온 과정은 아래 사진과 같습니다.  위 사진에서 가장 아래 있는 물음표가 View Binding입니다. findViewById…","fields":{"slug":"/Android/view_binding/"},"frontmatter":{"date":"July 03, 2000","title":"[Android] View Binding","category":"Android","draft":false}}},{"node":{"excerpt":"Data Binding 먼저 데이터 바인딩에 대해 간략히 이야기하자면, xml위에서 코딩하는 방식입니다. 선언적 형식으로 앱의 데이터 소스와 UI의 구성요소를 결합합니다. 위와 같은 두 코드가 있을 때, Activity나 Fragment에서 따로 코드를 작성하지 않아도, viewModel에 있는 text 123을 xml의 TextView에 띄울 수 있습니…","fields":{"slug":"/Android/two_way_data_binding/"},"frontmatter":{"date":"July 03, 2000","title":"[Android] Two-way Data Binding","category":"Android","draft":false}}},{"node":{"excerpt":"메모리 관리 시뮬레이션 Heap allocation Algorithm Buddy memory allocation - Wikipedia Heap 자료구조는 주로 동적으로 할당되며 블록의 크기가 일정하지 않습니다. 따라서 외부 단편화가 생기는 경우가 많으며 이를 방지하기 위해 빈 공간을 찾아 집어넣는 과정이 필요합니다. 때문에 연결리스트나 해쉬맵 자료구조가 …","fields":{"slug":"/O.S./GC/"},"frontmatter":{"date":"July 02, 2000","title":"[OS] Garbage Collector","category":"O.S.","draft":false}}},{"node":{"excerpt":"1. 캐시 캐시 컴퓨터를 구성하는 메모리는 다양한 종류가 있습니다. 대표적으로 RAM, SSD, HDD가 있습니다. SSD와 RAM의 차이는 무엇일까요? 간단하게 용량과 거리라고 생각하면 됩니다. RAM에 저장된 파일은 빠르게 탐색할 수 있지만 용량이 적습니다. SSD에는 파일을 많이 저장할 수 있지만 램보다는 느린 속도를 보입니다. 캐시메모리 역시 메모…","fields":{"slug":"/O.S./cache/"},"frontmatter":{"date":"July 02, 2000","title":"[OS] Cache","category":"O.S.","draft":false}}},{"node":{"excerpt":"리눅스는 서버 환경에 원격으로 접속해서 원하는 작업을 할 수 있는 운영체제입니다. GUI 환경 보다는 CLI 환경을 주로 사용하며 명령어에 익숙해진다면 보다 능률좋은 작업을 진행할 수 있습니다. 다중 사용자가 원격으로 접속해 사용하는 멀티유저 환경을 지향하는 이 운영체제는 어떻게 쓰이는지 보겠습니다. 1. 설치 리눅스가 어떻게 쓰이는지 직접 확인해보기 위…","fields":{"slug":"/O.S./Linux/"},"frontmatter":{"date":"July 02, 2000","title":"[OS] Linux","category":"O.S.","draft":false}}},{"node":{"excerpt":"Collection 함수의 생성 Collection에는 listOf, setOf, mapOf와 같은 함수가 존재합니다. 여기서 선언한 array의 원소는 변경할 수 없고, 변경하려면 mutable한 collection 함수로 생성해야 합니다. Mutable vs Immutable 직역하면 변할 수 있는, 변할 수 없는 이라는 뜻입니다. Kotlin에서 변…","fields":{"slug":"/Android/collection/"},"frontmatter":{"date":"July 02, 2000","title":"[Android] Collection","category":"Android","draft":false}}},{"node":{"excerpt":"LiveData LiveData는 관찰자 패턴을 활용한 Data Holder로 볼 수 있습니다. 간단하게 말해서 value를 set, post하는 과정을 Observe 합니다. MVVM을 예시로 들면, ViewModel에서 post한 데이터를 Activity에서 observe해 사용합니다. 추가로, postValue가 여러번 호출된다면 최신의 값이 적용되…","fields":{"slug":"/Android/livedata/"},"frontmatter":{"date":"July 02, 2000","title":"[Android] LiveData","category":"Android","draft":false}}},{"node":{"excerpt":"Recycler View 영어 뜻 그대로 재활용하는 뷰를 의미합니다. 스크롤을 자동으로 지원하며 화면에서 사라지거나 생겨나는 뷰를 재사용합니다. 구성 뷰의 구성요소를 참조할 때에는  메서드를 사용하게 됩니다.\n뷰를 재사용할 때마다 해당 메서드를 호출하는 것은 비용이 커질 수 있습니다.\n이 때 각 뷰 객체를 뷰홀더에 보관함으로써 반복적 호출 메서드를 줄여 …","fields":{"slug":"/Android/recyclerview/"},"frontmatter":{"date":"July 02, 2000","title":"[Android] RecyclerView","category":"Android","draft":false}}},{"node":{"excerpt":"kotlin.runCatching 예외처리는 흔하게 try / catch문을 사용한다고 알고 있습니다. 개발자라면 가독성이 좋은 코드를 쫓기 마련입니다. 저는 runCatching문이 더 예뻐보이지만 가독성은 집단마다 차이가 있기 때문에 선호하는대로 사용하면 될 것 같네요!","fields":{"slug":"/Android/run_catching/"},"frontmatter":{"date":"July 02, 2000","title":"[Android] 예외처리: run catching","category":"Android","draft":false}}},{"node":{"excerpt":"ViewModel viewModel은 Android Jetpack의 구성요소이며 UI 관련 데이터를 관리합니다. MVC 패턴에서 Controller에 과도한 책임이 할당되는 문제를 어느정도 해결해줍니다. 특징 UI 컨트롤러의 수명 주기를 관리합니다. 컨트롤러 로직에서 뷰 데이터 소유권을 분리하는 목적으로 사용합니다. 클래스를 분리하기 때문에 다른 화면에서…","fields":{"slug":"/Android/viewmodel/"},"frontmatter":{"date":"July 02, 2000","title":"[Android] ViewModel","category":"Android","draft":false}}},{"node":{"excerpt":"아키텍처 패턴 프로젝트의 규모가 점점 커지다보면 유지보수를 고려해야 합니다. Android는 마켓 정책 상 코드가 변경이 될 때도, 고객의 요구사항이 변경이 될 때도, 버전이 높아지며 deprecated되는 코드를 변경할 때에도 유지보수가 필요합니다. 객체지향적인 개념을 다시 생각해보기도 하고, 디자인 패턴을 적용해보기도 하고 아키텍쳐 패턴을 고려하기도 …","fields":{"slug":"/Android/mvc/"},"frontmatter":{"date":"July 01, 2000","title":"[Android] MVC 패턴","category":"Android","draft":false}}},{"node":{"excerpt":"MV? 패턴 디자인 패턴은 코드의 수정과 이해를 돕습니다. 의존성을 덜어내 테스트도 수월해지게 됩니다. 안드로이드에서 MV? 패턴에는 MVC - MVP - MVVM - MVI 패턴 등 여러가지가 존재합니다. 그 중 MVVM 패턴은 Model, View, ViewModel로 나뉘어져 있습니다. View MVVM패턴에서 Activity, Fragment와 같…","fields":{"slug":"/Android/mvvm/"},"frontmatter":{"date":"July 01, 2000","title":"[Android] MVVM 패턴","category":"Android","draft":false}}}]}},"pageContext":{}},"staticQueryHashes":["2486386679","3128451518"]}