{"componentChunkName":"component---src-templates-blog-post-js","path":"/Android/livedata_to_flow/","result":{"data":{"site":{"siteMetadata":{"title":"Cha-Ji","author":"Cha-Ji","siteUrl":"https://Cha-Ji.github.io","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"chaji"}}},"markdownRemark":{"id":"ef569c97-e718-59f7-b272-00f32ae19f51","excerpt":"MVVM 패턴을 적용하다보면 View와 ViewModel의 관심사 분리를 위해 노력하곤 합니다. 그 중 이벤트 처리와 데이터를 다루는 객체로 LiveData를 사용했습니다. 기존에 사용하던 LiveData에서 Coroutine Flow로 마이그레이션하며 개념을 정리하려 합니다. 짧은 사전 설명 xml에서 버튼을 클릭하면 Fragment에서는 원하는 화면으로 전환합니다. 해당 동작을 dataBinding을 사용해 아래처럼 구현했습니다. Fragment에선 viewModel의 flow…","html":"<p>MVVM 패턴을 적용하다보면 View와 ViewModel의 관심사 분리를 위해 노력하곤 합니다.<br>\n그 중 이벤트 처리와 데이터를 다루는 객체로 LiveData를 사용했습니다.<br>\n기존에 사용하던 LiveData에서 Coroutine Flow로 마이그레이션하며 개념을 정리하려 합니다.</p>\n<h2 id=\"짧은-사전-설명\" style=\"position:relative;\"><a href=\"#%EC%A7%A7%EC%9D%80-%EC%82%AC%EC%A0%84-%EC%84%A4%EB%AA%85\" aria-label=\"짧은 사전 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>짧은 사전 설명</h2>\n<p>xml에서 버튼을 클릭하면 Fragment에서는 원하는 화면으로 전환합니다.<br>\n해당 동작을 dataBinding을 사용해 아래처럼 구현했습니다.</p>\n<ol>\n<li>Fragment에선 viewModel의 flow를 구독합니다.</li>\n<li>flow 데이터의 값을 수신하면 원하는 화면으로 전환합니다.</li>\n<li>xml에서 viewModel의 emit 함수를 실행시킵니다.</li>\n<li>viewModel에선 flow 값을 발행시킵니다.</li>\n</ol>\n<h2 id=\"livedata---flow\" style=\"position:relative;\"><a href=\"#livedata---flow\" aria-label=\"livedata   flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LiveData -> Flow</h2>\n<p>Domain Layer에서 반환값을 liveData로 사용하면 Android 패키지를 import하게 됩니다.<br>\n하지만 Domain Layer는 kotlin으로만 이루어져 있어 Coroutine Flow를 사용하게 되었습니다.</p>\n<h2 id=\"sharedflow-stateflow\" style=\"position:relative;\"><a href=\"#sharedflow-stateflow\" aria-label=\"sharedflow stateflow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SharedFlow, StateFlow?</h2>\n<p>LiveData는 StateFlow와 유사하다는 얘기를 듣고 SharedFlow와 StateFlow의 차이가 궁금해 정리하게 되었습니다.</p>\n<h2 id=\"hot-stream-sharedflow\" style=\"position:relative;\"><a href=\"#hot-stream-sharedflow\" aria-label=\"hot stream sharedflow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hot Stream (SharedFlow)</h2>\n<p>Hot Stream은 방송국과 같습니다.<br>\n구독자가 없어도 값을 계속 방출한다는 특징이 있으며, 모든 구독자는 같은 데이터 스트림을 공유합니다.<br>\n이는 pub-sub 패턴과 유사하다고 볼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">testSharedFlow</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">data</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> sharedFlow<span class=\"token operator\">:</span> SharedFlow<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">data</span><span class=\"token punctuation\">.</span><span class=\"token function\">sharedIn</span><span class=\"token punctuation\">(</span>\n        scope <span class=\"token operator\">=</span> viewModelScope<span class=\"token punctuation\">,</span>\n        started <span class=\"token operator\">=</span> SharingStarted<span class=\"token punctuation\">.</span>Eagerly<span class=\"token punctuation\">,</span>\n        replay <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일반 flow에 sharedIn 메서드를 붙여 SharedFlow로 사용할 수 있습니다.<br>\nsharedIn 메서드에는 매개변수가 세개 필요합니다.</p>\n<ol>\n<li>어떤 코루틴 스코프에서 작동할지</li>\n<li>데이터 방출 시작방식</li>\n<li>각 새 collector로 재생할 항목의 수</li>\n</ol>\n<p>여기서 2번째인 started 매개변수의 설명을 더하자면 세가지 방식이 존재합니다.</p>\n<ul>\n<li>첫 구독자가 나타날 때 방출하는 Lazily 방식</li>\n<li>선언과 함께 방출하는 Eagerly 방식</li>\n<li>구독자가 존재하는 동안만 방출하는 등의 WhileSubscribed 방식</li>\n</ul>\n<p>해당 SharingStarted 객체는 Cold Stream에서도 매개변수로 활용하게 됩니다.</p>\n<h2 id=\"cold-stream-stateflow\" style=\"position:relative;\"><a href=\"#cold-stream-stateflow\" aria-label=\"cold stream stateflow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cold Stream (StateFlow)</h2>\n<p>Cold Stream은 Lazy합니다. LiveData의 쓰임새를 그대로 사용하려면 StateFlow를 사용하게 됩니다.<br>\n구독자가 생길 때마다 새 데이터 스트림을 생성한다는 특징이 있으며, 구독자가 생겨야 값을 방출하기 시작합니다.<br>\n이는 observer 패턴과 유사하다고 볼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">testStateFlow</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">data</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> stateFlowExample<span class=\"token operator\">:</span> StateFlow<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">data</span><span class=\"token punctuation\">.</span><span class=\"token function\">stateIn</span><span class=\"token punctuation\">(</span>\n        scope <span class=\"token operator\">=</span> viewModelScope<span class=\"token punctuation\">,</span> \n        started <span class=\"token operator\">=</span> SharingStarted<span class=\"token punctuation\">.</span>Eagerly<span class=\"token punctuation\">,</span>\n        initialValue <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"\"</span></span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일반 flow에 stateIn 메서드를 붙여 StateFlow로 사용할 수 있습니다.<br>\nstateIn 메서드에는 매개변수가 세개 필요합니다.</p>\n<ol>\n<li>어떤 코루틴 스코프에서 작동할지</li>\n<li>데이터 방출 시작방식</li>\n<li>디폴트값</li>\n</ol>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<ul>\n<li><a href=\"https://myungpyo.medium.com/%EC%BD%9C%EB%93%9C-%ED%94%8C%EB%A1%9C%EC%9A%B0-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-437a5edcd598\">https://myungpyo.medium.com/콜드-플로우-효율적으로-사용하기-437a5edcd598</a></li>\n</ul>","frontmatter":{"title":"[Kotlin] LiveData -> Coroutine Flow","date":"November 06, 2021"}}},"pageContext":{"slug":"/Android/livedata_to_flow/","previous":{"fields":{"slug":"/Android/reflection/"},"frontmatter":{"title":"[Java] Reflection"}},"next":{"fields":{"slug":"/O.S./10_대용량_저장장치_구조/"},"frontmatter":{"title":"[공룡책] 대용량 저장장치 구조"}}}},"staticQueryHashes":["2486386679","3128451518"]}