{"componentChunkName":"component---src-templates-blog-post-js","path":"/O.S./4_scheduling/","result":{"data":{"site":{"siteMetadata":{"title":"Cha-Ji","author":"Cha-Ji","siteUrl":"https://Cha-Ji.github.io","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"chaji"}}},"markdownRemark":{"id":"ee6fccfd-a602-54ff-82a3-241da73a152b","excerpt":"운영체제는 CPU를 프로세스 간 교환함으로써 보다 생산적으로 동작합니다. 코어가 하나인 시스템에선 한순간에 오직 하나의 프로세스만이 실행될 수 있습니다. 나머지 프로세스는 CPU의 코어가 가용 상태가 되어야 실행시킬 수 있으며 다중 프로그래밍의 목적은 CPU…","html":"<p>운영체제는 CPU를 프로세스 간 교환함으로써 보다 생산적으로 동작합니다.</p>\n<p>코어가 하나인 시스템에선 한순간에 오직 하나의 프로세스만이 실행될 수 있습니다.</p>\n<p>나머지 프로세스는 CPU의 코어가 가용 상태가 되어야 실행시킬 수 있으며</p>\n<p>다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행중인 프로세스를 가지게 하는 데 있습니다.</p>\n<p>이 때 프로세스 또는 스레드 바쁘게 사용하기 위한 스케줄링에 대해 알아보겠습니다.</p>\n<h2 id=\"스케줄링\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링</h2>\n<hr>\n<p>그냥 선착순으로 실행하고 끝내면 공평할텐데 왜 스케줄링 알고리즘이 필요할까요?</p>\n<p>은행에 사람이 7명 줄을 섭니다.</p>\n<p>맨 앞사람은 3시간짜리 업무를 보러 왔습니다. 그 뒤에 6사람은 모두 5분이 걸립니다.</p>\n<p>6사람은 다들 3시간 이상의 대기시간을 갖습니다. 총 대기시간은 20시간 정도 되네요.</p>\n<table>\n<thead>\n<tr>\n<th>사람”</th>\n<th>걸리는 시간”</th>\n<th>대기 시간”</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>가</td>\n<td>3시간</td>\n<td>0분</td>\n</tr>\n<tr>\n<td>나</td>\n<td>5분</td>\n<td>3시간</td>\n</tr>\n<tr>\n<td>다</td>\n<td>5분</td>\n<td>3시간 5분</td>\n</tr>\n<tr>\n<td>라</td>\n<td>5분</td>\n<td>3시간 10분</td>\n</tr>\n<tr>\n<td>마</td>\n<td>5분</td>\n<td>3시간 15분</td>\n</tr>\n<tr>\n<td>바</td>\n<td>5분</td>\n<td>3시간 20분</td>\n</tr>\n<tr>\n<td>사</td>\n<td>5분</td>\n<td>3시간 25분</td>\n</tr>\n</tbody>\n</table>\n<p>물론 먼저온 사람이 먼저 업무를 보는것이 공평하지만</p>\n<p>프로세스에게 공평함이 필요할까요? 총 대기시간만 적으면 될 것 같은데..</p>\n<p>오래 걸리는 사람이 제일 늦게 업무를 본다면 어떨까요? 대기시간은 2시간조차 되지 않네요.</p>\n<table>\n<thead>\n<tr>\n<th>사람”</th>\n<th>걸리는 시간”</th>\n<th>대기 시간”</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>나</td>\n<td>5분</td>\n<td>0분</td>\n</tr>\n<tr>\n<td>다</td>\n<td>5분</td>\n<td>5분</td>\n</tr>\n<tr>\n<td>라</td>\n<td>5분</td>\n<td>10분</td>\n</tr>\n<tr>\n<td>마</td>\n<td>5분</td>\n<td>15분</td>\n</tr>\n<tr>\n<td>바</td>\n<td>5분</td>\n<td>20분</td>\n</tr>\n<tr>\n<td>사</td>\n<td>5분</td>\n<td>25분</td>\n</tr>\n<tr>\n<td>가</td>\n<td>3시간</td>\n<td>30분</td>\n</tr>\n</tbody>\n</table>\n<p>이처럼, 큰 프로그램이 메모리를 점거해 전체적인 성능 저하를 불러일으키는 것 때문에<br>\n스케줄링 알고리즘이 필요합니다.</p>\n<p>스케줄링에는 크게 선점 스케줄링과 비선점 스케줄링이 있습니다.</p>\n<p>선점 스케줄링은 스케줄링이 발생할 때 기존 실행중인 프로세스를 선점하는 기법입니다.</p>\n<p>데드락을 방지할 필요가 있는 기법입니다.</p>\n<ul>\n<li>new process → runnint</li>\n<li>running process → waiting</li>\n</ul>\n<p>비선점 스케줄링은 context switching 전에 실행이 완료되고 프로세스가 봉쇄되기를 기다립니다.</p>\n<ul>\n<li>running process ~~~ running</li>\n</ul>\n<h2 id=\"스케줄링-기법\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EA%B8%B0%EB%B2%95\" aria-label=\"스케줄링 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링 기법</h2>\n<h3 id=\"선입선처리-스케줄링fcfs\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%9E%85%EC%84%A0%EC%B2%98%EB%A6%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81fcfs\" aria-label=\"선입선처리 스케줄링fcfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선입선처리 스케줄링(FCFS)</h3>\n<blockquote>\n<p>First-Come First-Served</p>\n</blockquote>\n<p>비선점형 기법입니다.</p>\n<p>먼저 실행된 프로세스부터 처리하며 CPU 버스트가 완료될 때까지 CPU를 반환하지 않습니다.</p>\n<p>단점으로는 긴 프로세스가 CPU를 양도하길 기다리는 호위 효과가 발생합니다.</p>\n<h3 id=\"최단작업우선-스케줄링sjf\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EB%8B%A8%EC%9E%91%EC%97%85%EC%9A%B0%EC%84%A0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81sjf\" aria-label=\"최단작업우선 스케줄링sjf permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최단작업우선 스케줄링(SJF)</h3>\n<blockquote>\n<p>Shortest-Job-First</p>\n</blockquote>\n<p>평균 대기시간이 최소인 스케줄링 기법입니다.</p>\n<p>이상적이지만 문제점이 있습니다. 실제로 실행되지도 않은 CPU 버스트의 길이를 예언하는건 불가능합니다.</p>\n<p>때문에 이전 버스트의 길이와 비슷하다고 기대하고 예측하여 사용합니다.</p>\n<p>단점으로는 긴 프로세스는 평생 실행시킬 수 없는 효과가 발생합니다.</p>\n<h3 id=\"라운드-로빈-스케줄링rr\" style=\"position:relative;\"><a href=\"#%EB%9D%BC%EC%9A%B4%EB%93%9C-%EB%A1%9C%EB%B9%88-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81rr\" aria-label=\"라운드 로빈 스케줄링rr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>라운드 로빈 스케줄링(RR)</h3>\n<blockquote>\n<p>Round-Robin</p>\n</blockquote>\n<p>FCFS에서 선점이 추가된 방식입니다.</p>\n<p>각 프로세스는 동일한 크기의 할당 시간을 갖게됩니다.</p>\n<p>할당시간이 끝나면 선점당하며 준비 큐의 맨 뒤로 가게됩니다.</p>\n<p>할당 시간이 너무 크면 FCFS와 같아져서 문제가 되지만 문맥 교환 시간에 비해서는 커야합니다.</p>\n<h3 id=\"우선순위-스케줄링\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"우선순위 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선순위 스케줄링</h3>\n<blockquote>\n<p>Priority</p>\n</blockquote>\n<p>우선순위가 가장 높은 프로세스에게 CPU를 할당하는 스케줄링입니다.</p>\n<p>선점과 비선점 모두 가능합니다.</p>\n<p>선점형에서는 더 높은 우선순위의 프로세스가 도착하면 선점하며,</p>\n<p>비선점형에서는 준비 큐의 head에 넣게 됩니다.</p>\n<p>단점으로는 실행준비는 되어있지만 CPU를 사용할 수 없는 프로세스를 CPU가 무한히 대기하는 상태가 존재합니다.</p>\n<p>하지만 해결책으로 대기시간에 따라 우선순위를 보정하는 aging이 존재합니다.</p>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<hr>\n<ul>\n<li><a href=\"https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC\">github JaeYeopHan</a></li>\n<li>Abraham Silberschatz, Peter B. Galvin, Greg Gagne의 『Operating System Concept 10th』</li>\n</ul>","frontmatter":{"title":"[공룡책] CPU 스케줄링","date":"July 04, 2020"}}},"pageContext":{"slug":"/O.S./4_scheduling/","previous":{"fields":{"slug":"/O.S./queue/"},"frontmatter":{"title":"[OS] 다단계 큐와 다단계 피드백 큐"}},"next":{"fields":{"slug":"/O.S./5_sync/"},"frontmatter":{"title":"[공룡책] 동기화"}}}}}