{"componentChunkName":"component---src-templates-blog-post-js","path":"/O.S./6_sync_ex/","result":{"data":{"site":{"siteMetadata":{"title":"Cha-Ji","author":"Cha-Ji","siteUrl":"https://Cha-Ji.github.io","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"chaji"}}},"markdownRemark":{"id":"a17d3fbd-c367-5977-a055-7d7a847f2d3b","excerpt":"Operating System - 동기화 이전 글에서는 발생할 수 있는 문제에 대해 많이 언급했습니다. 또한 임계구역 문제, 경쟁조건이 없는 프로그램을 설계할 때 발생하는 문제, 교착상태, 라이브니스 위험 등을 언급했습니다. 이 글에서는 제시된 도구를 고전적인 동기화 문제에 적용합니다. 유한 버퍼 문제 먼저 유한 버퍼 문제가 존재합니다. 유한한 개수의 item을 임시로 보관하는 버퍼에 여러 명의 생산자들과 소비자들이 접근한다. \n생산자는 item…","html":"<p><a href=\"/1f5e129a070e20d28acbefc0f6aea615/5_sync.md\">Operating System - 동기화</a></p>\n<p>이전 글에서는 발생할 수 있는 문제에 대해 많이 언급했습니다.</p>\n<p>또한 임계구역 문제, 경쟁조건이 없는 프로그램을 설계할 때 발생하는 문제, 교착상태, 라이브니스 위험 등을 언급했습니다.</p>\n<p>이 글에서는 제시된 도구를 고전적인 동기화 문제에 적용합니다.</p>\n<h2 id=\"유한-버퍼-문제\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%ED%95%9C-%EB%B2%84%ED%8D%BC-%EB%AC%B8%EC%A0%9C\" aria-label=\"유한 버퍼 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유한 버퍼 문제</h2>\n<p>먼저 유한 버퍼 문제가 존재합니다.</p>\n<blockquote>\n<p>유한한 개수의 item을 임시로 보관하는 버퍼에 여러 명의 생산자들과 소비자들이 접근한다.\n생산자는 item이 하나 만들어지면 그 공간에 저장한다.\n이때 저장할 공간이 없는 문제가 발생할 수 있다.\n소비자는 item이 필요할 때 버퍼에서 item을 하나 가져온다.\n이 때는 소비할 item이 없는 문제가 발생할 수 있다.</p>\n</blockquote>\n<ul>\n<li>출처: <a href=\"https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C\">https://ko.wikipedia.org/wiki/생산자-소비자_문제</a></li>\n</ul>\n<p>이 문제를 해결하는 것을 생산자-소비자 협동이라 하며 버퍼가 동기화되어 정상적으로 동작하는 상태를 뜻합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// n개의 버퍼로 구성된 pool이 존재하며 각 버퍼는 한 item을 저장</span>\n<span class=\"token keyword\">val</span> n<span class=\"token operator\">:</span> Int\n<span class=\"token keyword\">var</span> mutex<span class=\"token operator\">:</span> Semaphore <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token comment\">// 상호 배제 기능을 제공</span>\n<span class=\"token keyword\">var</span> empty<span class=\"token operator\">:</span> Semaphore <span class=\"token operator\">=</span> n  <span class=\"token comment\">// 비어있는 버퍼 수</span>\n<span class=\"token keyword\">var</span> full<span class=\"token operator\">:</span> Semaphore <span class=\"token operator\">=</span> <span class=\"token number\">0</span>   <span class=\"token comment\">// 사용중인 버퍼 수</span>\n\n<span class=\"token comment\">//================================================</span>\n<span class=\"token comment\">// 생산자</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// produce</span>\n  <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// next produce</span>\n  <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//================================================</span>\n<span class=\"token comment\">// 소비자</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span>\n   <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span>\n   <span class=\"token comment\">// remove item</span>\n\n   <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span>\n   <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span>\n   <span class=\"token comment\">//consume</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"readers-writers-문제\" style=\"position:relative;\"><a href=\"#readers-writers-%EB%AC%B8%EC%A0%9C\" aria-label=\"readers writers 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Readers-Writers 문제</h3>\n<blockquote>\n<p>병행 프로세스들이 한 DB를 공유한다면 배타적 접근 권한이 필요합니다.</p>\n</blockquote>\n<ol>\n<li>첫 번째 문제</li>\n<li>공유 객체를 사용할 수 있는 허가를 얻지 못했다면, 다른 reader들이 끝날 때까지 기다리는 reader가 있으면 안된다.</li>\n<li>→ writer의 starvation</li>\n<li>두 번째 문제</li>\n<li>writer가 접근중이라면, 새 reader들은 읽기를 시작할 수 없다.</li>\n<li>→ reader의 starvation</li>\n</ol>\n<h3 id=\"reader-wirter-lock\" style=\"position:relative;\"><a href=\"#reader-wirter-lock\" aria-label=\"reader wirter lock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reader-wirter lock</h3>\n<blockquote>\n<p>해당 문제는 두 가지모드를 지원하는 락을 둬서 해결합니다.</p>\n</blockquote>\n<ul>\n<li>읽기모드의 락, 쓰기모드의 락이 존재합니다.</li>\n<li>reader 락은 여러 프로세스가 동시에 획득하는 것이 가능합니다.</li>\n<li>writer 락은 하나의 프로세스만 획득할 수 있습니다.</li>\n</ul>\n<p>다음과 같은 상황에서 유용합니다.</p>\n<ul>\n<li>공유데이터를 읽기만하는 프로세스와 쓰기만하는 스레드를 식별하기 쉬운 응용</li>\n<li>\n<p>Wirter보다 reader의 개수가 많은 응용</p>\n<ul>\n<li>reader-writer lock을 설정하는 오버헤드는 semaphore나 mutex를 설정할 때보다 큽니다.</li>\n<li>reader들의 병행성을 높여 상쇄합니다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"식사하는-철학자\" style=\"position:relative;\"><a href=\"#%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90\" aria-label=\"식사하는 철학자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>식사하는 철학자</h2>\n<blockquote>\n<p>이전 글에서 언급한 식사하는 철학자 문제의 해결안을 살펴봅니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 일정 시간 생각을 한다.\n2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.\n3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.\n4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.\n5. 오른쪽 포크를 내려놓는다.\n6. 왼쪽 포크를 내려놓는다.\n7. 다시 1번으로 돌아간다</code></pre></div>\n<ul>\n<li>\n<p>두 포크를 모두 집을 수 있는지 판단한 뒤에 집습니다.</p>\n<ul>\n<li>임계구역 안에서만 포크를 집어야합니다.</li>\n</ul>\n</li>\n<li>\n<p>비대칭 해결안을 활용합니다.</p>\n<ul>\n<li>예를 들어, 홀수번호는 왼쪽 포크부터 집고 짝수번호는 오른쪽 포크부터 집습니다.</li>\n</ul>\n</li>\n<li>\n<p>우선순위로 해결합니다.</p>\n<ul>\n<li>포크에 우선순위를 두고 양쪽 포크 중 우선순위가 높은 포크부터 집습니다.</li>\n<li>한 명은 하나의 포크도 집을 수 없게 되고 한명이 식사를 마치면 두명씩 식사를 할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>시간제한으로 해결합니다.</p>\n<ul>\n<li>사용하지 않는 포크에 시간제한을 둡니다.</li>\n<li>동시에 내려놓지 않는다고 가정하면 한 명이 포크를 내려놓는 순간 옆자리 한명이 식사를 시작하게 됩니다.</li>\n</ul>\n</li>\n</ul>\n<p>해당 해결안들은 효율성이 고려되지 않았습니다.</p>\n<p>데드락이 없는 해결안이 반드시 기아의 가능성도 제거하지는 않습니다.</p>\n<h2 id=\"모니터\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8B%88%ED%84%B0\" aria-label=\"모니터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모니터</h2>\n<blockquote>\n<p>앞서 언급한 식사하는 철학자의 해결안을 제시하며 모니터의 개념을 설명합니다.</p>\n</blockquote>\n<p>양쪽 포크를 모두 집을 수 있을 때에만 포크를 집을 수 있도록 강제합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">enum class State {\n    THINKING,\n    HUNGRY,\n    EATING\n}\n\nclass DiningPhilosophers : Monitor {\n\n    val state = mutableListOf&lt;State>()\n\n    // 원하는 포크를 집을 수 없을 때 집기를 미룰 수 있게 한다.    \n    val self = mutableListOf&lt;Condition>() \n\n    init {\n        (0..5).forEach { i ->\n            state.append(THINKING)\n        }\n    }\n\n    // 식사 전\n    fun pickUp(i: Int) {\n        state[i] = HUNGRY\n        eat(i)\n\n        if (state[i] != EATING) self[i].wait()    \n  }\n\n  // 식사 후\n    fun putDown(i: Int) {\n        state[i] = THINKING\n        eat(left(i))\n        eat(right(i))\n    }\n\n    private fun left(i: Int) = (i + 4) % 5\n\n    private fun right(i: Int) = (i + 1) % 5\n\n    fun eat(i: Int) {\n        if (canEat(i)) {\n                state[i] = EATING\n                self[i].signal()\n        }\n    }\n\n    private fun canEat(i: Int) = state[left(i)] != EATING &amp;&amp; \n        state[i] == HUNGRY &amp;&amp; \n        state[right(i)] != EATING\n}</code></pre></div>\n<ul>\n<li>해당 코드는 공룡책 그림7.7의 코드를 kotlin으로 작성했으며, 가독성을 위해 코드를 세분화한 코드입니다.</li>\n</ul>\n<p>데드락을 해결한 코드이지만 기아 상태를 해결하진 못했습니다.</p>\n<h3 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h3>\n<ul>\n<li>Abraham Silberschatz, Peter B. Galvin, Greg Gagne의 『Operating System Concept 10th』</li>\n</ul>","frontmatter":{"title":"[공룡책] 동기화 예제","date":"July 04, 2022"}}},"pageContext":{"slug":"/O.S./6_sync_ex/","previous":{"fields":{"slug":"/O.S./5_sync/"},"frontmatter":{"title":"[공룡책] 동기화"}},"next":{"fields":{"slug":"/O.S./10_대용량_저장장치_구조/"},"frontmatter":{"title":"[공룡책] 대용량 저장장치 구조"}}}},"staticQueryHashes":["2486386679","3128451518"]}