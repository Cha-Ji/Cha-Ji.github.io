{"componentChunkName":"component---src-templates-blog-post-js","path":"/O.S./7_deadlock/","result":{"data":{"site":{"siteMetadata":{"title":"Cha-Ji","author":"Cha-Ji","siteUrl":"https://Cha-Ji.github.io","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"chaji"}}},"markdownRemark":{"id":"a1d42397-84fe-5518-932a-1b2674918a8b","excerpt":"이전 글에서 동기화에 대한 이야기를 하며 교착상태라는 이야기가 나왔습니다. Operating System - 동기화 Operating System - 동기화 예제 교착상태는 세마포가 Ready Queue 를 가지고 있고 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고 Critical Section…","html":"<p>이전 글에서 동기화에 대한 이야기를 하며 교착상태라는 이야기가 나왔습니다.</p>\n<p><a href=\"https://cha-ji.tistory.com/entry/Operating-System-%EB%8F%99%EA%B8%B0%ED%99%94\">Operating System - 동기화</a></p>\n<p><a href=\"https://cha-ji.tistory.com/entry/Operating-System-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%98%88%EC%A0%9C\">Operating System - 동기화 예제</a></p>\n<p>교착상태는 세마포가 Ready Queue 를 가지고 있고 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고 Critical Section 에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되야만 빠져나올 수 있는 상황을 말합니다.</p>\n<p>이전 글에서 예방에 대한 내용을 보충하기 위해 작성했습니다.</p>\n<h3 id=\"교착상태의-필요조건\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%A1%B0%EA%B1%B4\" aria-label=\"교착상태의 필요조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착상태의 필요조건</h3>\n<ol>\n<li>상호 배제(mutual exclusion): 최소 하나의 자원이 비공유 모드로 점유되어야 합니다.</li>\n<li>점유 대기(hold and wait): 최소 하나의 자원을 점유한 채 다른 점유된 자원을 얻기 위해 대기해야 합니다.</li>\n<li>비선점(no preemption): 자원을 선점할 수 없어야 합니다.</li>\n<li>순환 대기(circular wait): 다음 스레드가 점유한 자원을 대기하는 것이 순환됩니다.</li>\n</ol>\n<p>이 네가지 조건이 모두 성립되면 데드락이 발생합니다.</p>\n<p>1, 2, 3번은 병행 프로그래밍을 수행하기 위해 필요한 조건들이고 일반적으로 4번을 예방해서 데드락을 없앱니다.</p>\n<h3 id=\"교착상태-예방\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EC%98%88%EB%B0%A9\" aria-label=\"교착상태 예방 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착상태 예방</h3>\n<p>1. 상호 배제</p>\n<ul>\n<li>자원을 공유해서 처리하는 방법입니다.</li>\n</ul>\n<p>mutex 락과 같은 근본적으로 공유가 불가능한 자원이 존재하기 때문에 불가능합니다.</p>\n<p>2. 점유 대기</p>\n<ul>\n<li>자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해서 처리하는 방법입니다.</li>\n</ul>\n<p>각 스레드가 실행하기 전에 모든 자원을 요청하고 할당해야 합니다.</p>\n<p>자원 이용률이 낮을 수 있고, starvation이 발생할 수 있다는 문제가 있기 때문에 꺼려집니다.</p>\n<p>3. 비선점</p>\n<ul>\n<li>자원을 선점해서 처리하는 방법입니다.</li>\n</ul>\n<p>사용중인 자원이더라도 요청이 생기면 사용 가능한지를 검사하고 할당합니다.</p>\n<p>CPU 레지스터나 DB 트랜잭션처럼 상태의 저장과 복원이 쉬운 자원에 종종 적용됩니다.</p>\n<p>mutex락과 세마포같은 자원에는 적용될 수 없으며 교착상태를 해결하기에 어렵습니다.</p>\n<p>4. 순환 대기</p>\n<ul>\n<li>필요 조건 중 하나를 무효화해 순환을 없애는 방법입니다.</li>\n</ul>\n<p>앞서 제시한 세가지 옵션은 대부분 실용적이지 않습니다.</p>\n<p>자원 점유의 우선순위를 부여해 할당시키는 방법으로 순환 대기를 해결하곤 합니다.</p>\n<p>무한을 고려하지 않는 이상 스레드를 오름차순으로 정렬하면 끝이 있게 되고, 순환이 끊기게 됩니다.</p>\n<h3 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h3>\n<ul>\n<li>Abraham Silberschatz, Peter B. Galvin, Greg Gagne의 『Operating System Concept 10th』</li>\n</ul>","frontmatter":{"title":"[공룡책] 교착상태","date":"July 07, 2020"}}},"pageContext":{"slug":"/O.S./7_deadlock/","previous":{"fields":{"slug":"/O.S./peterson/"},"frontmatter":{"title":"[OS] 피터슨의 알고리즘"}},"next":{"fields":{"slug":"/O.S./8_main_memory/"},"frontmatter":{"title":"[공룡책] 메인메모리"}}}}}